#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <map>
#include <print>
#include <random>
#include <ranges>
#include <thread>

class XorBitant
{
  private:
    std::uint64_t m_state{0xDEADBEEFBABECAFE};

  public:
    using result_type = std::uint32_t;
    constexpr static inline std::uint64_t MAGIC_MULTIPLIER = 0x9E3779B97F4A7C15ULL;
    constexpr static inline std::uint64_t MAGIC_SEED = 0xDEAD'BEEF'BABE'CAFEULL;

    // Constructor to seed the generator
    explicit XorBitant(std::uint64_t seed = MAGIC_SEED) : m_state(seed)
    {
    }

    // Required: min value
    static constexpr result_type min()
    {
        return 0;
    }

    // Required: max value
    static constexpr result_type max()
    {
        return std::numeric_limits<std::uint32_t>::max();
    }

    // Generate next random number
    result_type operator()()
    {
        std::uint64_t x = m_state;
        x ^= x << 13;
        x ^= x >> 7;
        x ^= x << 5;
        m_state = x;
        return static_cast<result_type>(x * MAGIC_MULTIPLIER);
    }
};

int main()
{
    std::random_device rd;
    std::mt19937_64 gen{rd()};
    std::uint64_t single_clock_seed = std::chrono::steady_clock::now().time_since_epoch().count();
    std::uint64_t double_clock_seed = std::chrono::steady_clock::now().time_since_epoch().count() ^
                                      std::chrono::system_clock::now().time_since_epoch().count();
    std::uint64_t thread_double_clock_seed = std::chrono::steady_clock::now().time_since_epoch().count() ^
                                             std::chrono::system_clock::now().time_since_epoch().count() ^
                                             std::hash<std::thread::id>{}(std::this_thread::get_id());

    XorBitant xor_gen{thread_double_clock_seed};
    std::map<int, int> hist;
    constexpr int min_num = 0;
    constexpr int max_num = 6;
    // constexpr int n = max_num - min_num;
    std::uniform_int_distribution dist(min_num, max_num);

    // plot ascii histogram using the `hist` map and the generated XorBitant numbers
    // for (int i = 0; i < 10000; ++i)
    // {
    //     int num = dist(xor_gen);
    //     hist[num]++;
    // }
    // same as above using ranges
    std::ranges::for_each(std::views::iota(0, 10000), [&gen, &xor_gen, &hist, &dist](auto) { ++hist[dist(gen)]; });
    std::println("Histogram of random numbers (0-100) generated by XorBitant:");
    std::ranges::for_each(hist, [](const auto &pair) {
        std::print("{:3} | ", pair.first);
        for (int i = 0; i < pair.second / 100; ++i)
            std::print("*");
        std::println(" ({})", pair.second);
    });

    // Using XorBitant with distribution
    std::println("Random numbers with XorBitant:");
    std::ranges::for_each(std::views::iota(0) | std::views::take(10),
                          [&dist, &xor_gen](auto) { std::print("{} ", dist(xor_gen)); });

    // Shuffle a range/vector
    std::println("\n\nOriginal:");
    auto rng = std::views::iota(0, 10) | std::ranges::to<std::vector>();
    std::ranges::for_each(rng, [](const int el) { std::print("{} ", el); });

    std::println("\nAfter shuffling with XorBitant:");
    std::ranges::shuffle(rng, xor_gen);
    std::ranges::for_each(rng, [](const int el) { std::print("{} ", el); });

    return EXIT_SUCCESS;
}